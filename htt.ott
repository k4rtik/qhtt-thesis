metavar termvar, x ::=

metavar ghostvar, g, e, u ::=

metavar subspace, S ::=

metavar state, psi ::=
{{ tex \psi }}

metavar distribution, D ::=

grammar

Typ, A, B, C :: Ty ::= {{ com Types }}
  | K                  ::   :: K
  | bit                ::   :: Bit
  | qbit               ::   :: Qubit
  | unit               ::   :: Unit
  | prop               ::   :: Prop
  | mono               ::   :: MonoType
  | Pi x : A . B       ::   :: DepProd      {{ com Dependent Product }}
  | A -> B             ::   :: Arrow        {{ com Sugar for Pi type }}
  | Sig x : A . B      ::   :: DepSum       {{ com Dependent Sum }}
  | A times B          ::   :: Pair         {{ com Sugar for Sigma type }}
  | { x : A . P }      ::   :: Refinement   {{ com Type Refinement }}
  | { P } x : A { Q }  ::   :: Hoare        {{ com Hoare Type }}
  | QST x : A ( requires { P } )
    ( ensures { Q } )  ::   :: QHoare        {{ com Sugar for Q. Hoare Type }}
  | A [ M / x ]        :: M :: Substitution

Tm, K, L, M, N :: Tm ::= {{ com Terms }}
  | x           ::  :: Var
  | 0           ::  :: Zero
  | 1           ::  :: One
  | ()          ::  :: Unit
  | \ x . M     ::  :: Lam
  | K N         ::  :: App
  | ( M , N )   ::  :: Pair
  | fst K       ::  :: Fst
  | snd K       ::  :: Snd
  | in M        ::  :: In
  | out K       ::  :: Out
  | do E        ::  :: Do
  | M : A       ::  :: Ascription

Prop, P, Q, R :: '' ::= {{ com Propositions }}
  | top                   ::  :: Top          {{ com Complete state space, trivial }}
  | bot                   ::  :: Bottom       {{ com \{0\}, trivial }}
  | P /\ Q                ::  :: Conjunction  {{ com Intersection of subspaces. P, Q }}
  | P , Q                 :: S:: ConjSugar
  | P \/ Q                ::  :: Disjunction  {{ com Sum of subspaces }}
  | U o P                 ::  :: Unitary      {{ com Operator }}
  | x inq S               ::  :: InSubspace   {{ com x lies in subspace S }}
  | x =q psi              ::  :: EqState      {{ com x is equal to state $\psi$ }}
  | distrib ( x , D )     :: S:: Distrib
  | uniform ( x )         ::  :: Uniform      {{ com x is uniformly distributed }}
  | x1 ==q x2             ::  :: EqQuantum    {{ com quantum equality }}
  | separable ( x )       ::  :: Separable    {{ com x is separable. x $\equiv_q$ u}}
  | x1 ==cl x2            ::  :: EqClassical  {{ com classical equality }}
  | class ( x )           ::  :: Class        {{ com x is classical. x $\equiv_{cl}$ u}}
  | P [ M / x ]           :: M:: Substitution

Cmd, c :: '' ::= {{ com Commands }}
  | init M                :: :: Initialize
  | apply U to M          :: :: ApplyU
  | meas M                :: :: Measurement
  % | if M then E1 else E2  :: :: IfThenElse

Unitary, U :: '' ::= {{ com Unitaries }}
  | I     :: :: Identity
  | X     :: :: X
  | Y     :: :: Y
  | Z     :: :: Z
  | H     :: :: Hadamard
  % | S     :: :: Phase
  | CX    :: :: ControlledX
  | CZ    :: :: ControlledZ

Comp, E, F :: '' ::= {{ com Computations }}
  | return M        :: :: Return
  | x <- K ; E      :: :: Run
  | x <- c ; E      :: :: Bind
  | x = M ; E       :: :: Let

MonoTyp, t {{ tex \tau }}, s {{ tex \sigma }} :: 'Mon' ::= {{ com Monotypes }}
  | bit               :: :: Bit
  | qbit              :: :: Qubit
  | unit              :: :: Unit
  | prop              :: :: Proposition
  | Pi x : t . s      :: :: Pi
  | Sig x : t . s     :: :: Sigma
  | { x : t . P }     :: :: Refinement
  | { P } s : t { Q } :: :: Hoare

Ctx, G {{ tex \Gamma }} :: 'Ctx' ::= {{ com Contexts }}
  | o               :: :: Empty
  | G , x : A       :: :: Type
  | G , P           :: :: Prop


terminals :: 'terminals_' ::=
  | \                      ::   :: lambda     {{ tex \lambda }}
  | ==q                    ::   :: eqQuantum  {{ tex \equiv_q }}
  | ==cl                   ::   :: eqClass    {{ tex \equiv_{cl} }}
  | o                      ::   :: operator   {{ tex \cdot }}
  % | -->                    ::   :: red        {{ tex \longrightarrow }}
  % | |=                     ::   :: seqimp     {{ tex \models }}
  |  ->                    ::   :: arrow      {{ tex \rightarrow }}
  | <-                     ::   :: larrow     {{ tex \leftarrow }}
  |  =>                    ::   :: rbarrow    {{ tex \Rightarrow }}
  | <                      ::   :: langle     {{ tex \langle }}
  | >                      ::   :: rangle     {{ tex \rangle }}
  | |-                     ::   :: turnstile  {{ tex \vdash }}
  | inc                    ::   :: in         {{ tex \in }}
  | inq                    ::   :: inq        {{ tex \in_q }}
  | =q                     ::   :: eqq        {{ tex =_q }}
  | <-q                    ::   :: initq      {{ tex \stackrel{q}{\leftarrow} }}
  | Pi                     ::   :: pi         {{ tex \Pi }}
  | Sig                    ::   :: Sigma      {{ tex \Sigma }}
  | tau                    ::   :: tau        {{ tex \tau }}
  | sigma                  ::   :: sigma      {{ tex \sigma }}
  | psi                    ::   :: psi        {{ tex \psi }}
  | times                  ::   :: times      {{ tex \otimes }}
  | top                    ::   :: top        {{ tex \top }}
  | bot                    ::   :: bot        {{ tex \bot }}
  | /\                     ::   :: and        {{ tex \wedge }}
  | \/                     ::   :: or         {{ tex \vee }}
  | imp                    ::   :: imp        {{ tex \supset }}
  | not                    ::   :: not        {{ tex \neg }}
  | exists                 ::   :: exists     {{ tex \exists }}
  | forall                 ::   :: forall     {{ tex \forall }}
  | |->                    ::   :: SMapsto    {{ tex \mapsto }}


defns
  Jtype :: '' ::=

defn
  |- G ctx :: :: ctx :: ctx_ {{ com Checking contexts }} by

    -------- :: Empty
    |- o ctx

    |- G ctx
    G |- A type
    ------------- :: Type
    |- G, x:A ctx

    |- G ctx
    G |- P : prop
    --------------- :: Prop
    |- G, P ctx

defn
  G |- A type :: :: Type :: ty_ {{ com $[[A]]$ is a type }} by

    G |- K : mono
    --------------- :: Elim
    G |- K type

    -------------- :: Bit
    G |- bit type

    -------------- :: Prop
    G |- prop type

    -------------- :: Mono
    G |- mono type

    -------------- :: Unit
    G |- unit type

    G |- A type
    G, x:A |- B type
    ------------------ :: Pi
    G |- Pi x:A.B type

    G |- A type
    G, x:A |- B type
    ------------------ :: Sig
    G |- Sig x:A.B type

    G |- A type
    G, x:A |- P : prop
    -------------------- :: Refine
    G |- {x:A.P} type

defn
  A = B :: :: TyEq :: tyeq_ {{ com $[[A]]$ and $[[B]]$ are equal as types }} by

defn
  G |- M = N : A :: :: TmEq :: tmeq_ {{ com $[[M]]$ and $[[N]]$ are equal as terms of type $[[A]]$ }} by

defn
  G |- P : prop :: :: Prop :: prop_ {{ com $[[P]]$ type checks as a $[[prop]]$ }} by

defn
  G |- M : A :: :: Term :: tm_ {{ com term $[[M]]$ has type $[[A]]$ }} by

    G, x:A |- M : B
    ---------------------- :: PiI
    G |- \x.M : Pi x:A.B

    G |- M : A
    G |- N : B[M/x]
    ------------------------- :: SigI
    G |- (M, N) : Sig x:A.B

    G |- M : A
    D |= P[M/x]
    --------------------- :: RefineI
    G |- in M : {x:A.P}

    G |- K : A
    A = B
    ------------ :: Elim
    G |- K : B

    G |- K : Pi x:A.B
    G |- M : A
    ------------------- :: PiE
    G |- K M : B[M/x]

    G |- K : Sig x:A.B
    -------------------- :: FstE
    G |- fst K : A

    G |- K : Sig x:A.B
    --------------------------- :: SndE
    G |- snd K : B[fst K / x]

    G |- K : {x:A.P}
    ------------------ :: RefineE
    G |- out K : A

    G |- A type
    G |- M : A
    -------------- :: AscriptionE
    G |- M:A : A

defn
  D |= P :: :: Prove :: Pr_ {{ com Proof obligation $[[P]]$ }} by

    G |- K : {x:A.P}
    ------------------ :: Refine
    D |= P[out K / x]

defn
  D ; P |- E : x : A . Q :: :: CompIntro :: CompIn_ {{ com With $[[D]], [[P]], [[A]]$ check that $[[E]]$ returns a value of type $[[A]]$ with postcond. $[[Q]]$ }} by

defn
  D ; P |- E : x : A . Q :: :: CompElim :: CompEl_ {{ com With $[[D]], [[P]], [[E]], [[A]]$ as input, synthesize the strongest postcondition $[[Q]]$ }} by
